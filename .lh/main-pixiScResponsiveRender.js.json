{
    "sourceFile": "main-pixiScResponsiveRender.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1690685693529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1690685783639,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -64,26 +64,27 @@\n   let canvasWrapWidth = canvasWrap$.clientWidth\n   let canvasWrapHeight = canvasWrap$.clientHeight\n   canvasWrap$.appendChild(document.createElement('canvas'))\n   const canvas$ = sel('canvas')\n-  // const app = new PIXI.Application({\n-  //   width: canvasWrapWidth,\n-  //   height: canvasWrapHeight,\n-  //   resolution: window.devicePixelRatio,\n-  //   autoDensity: true,\n-  //   antialias: true,\n-  // })\n-  // const app = new PIXI.Application({ width: canvasWrapWidth, height: canvasWrapHeight, resolution: 1, antialias: true })\n-  // const app = new PIXI.Application({ width: vpWidth, height: vpHight, resolution: 1, antialias: true })\n-  // canvasWrap$.appendChild(app.view)\n-  const renderer = new PIXI.Renderer({\n+  const app = new PIXI.Application({\n     width: canvasWrapWidth,\n     height: canvasWrapHeight,\n     resolution: window.devicePixelRatio,\n     autoDensity: true,\n     antialias: true,\n-    view: canvas$,\n+      \n   })\n+  // const app = new PIXI.Application({ width: canvasWrapWidth, height: canvasWrapHeight, resolution: 1, antialias: true })\n+  // const app = new PIXI.Application({ width: vpWidth, height: vpHight, resolution: 1, antialias: true })\n+  // canvasWrap$.appendChild(app.view)\n+//   const renderer = new PIXI.Renderer({\n+//     width: canvasWrapWidth,\n+//     height: canvasWrapHeight,\n+//     resolution: window.devicePixelRatio,\n+//     autoDensity: true,\n+//     antialias: true,\n+//     view: canvas$,\n+//   })\n   const stage = new PIXI.Container()\n   const svg = 'https://uploads-ssl.webflow.com/64b5d89ecbb311f07e71739b/64c4afa6434d9807c6f188a7_map-woDots-pos2.svg'\n   const tex = PIXI.Texture.from(svg, { resourceOptions: { scale: 2 } })\n   const sprite = new PIXI.Sprite(tex)\n"
                },
                {
                    "date": 1690685954015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,45 +63,47 @@\n   const canvasWrap$ = sel('.canvas-wrap')\n   let canvasWrapWidth = canvasWrap$.clientWidth\n   let canvasWrapHeight = canvasWrap$.clientHeight\n   canvasWrap$.appendChild(document.createElement('canvas'))\n-  const canvas$ = sel('canvas')\n+  //   const canvas$ = sel('canvas')\n   const app = new PIXI.Application({\n     width: canvasWrapWidth,\n     height: canvasWrapHeight,\n     resolution: window.devicePixelRatio,\n     autoDensity: true,\n     antialias: true,\n   })\n+  canvasWrap$.appendChild(app.view)\n   // const app = new PIXI.Application({ width: canvasWrapWidth, height: canvasWrapHeight, resolution: 1, antialias: true })\n   // const app = new PIXI.Application({ width: vpWidth, height: vpHight, resolution: 1, antialias: true })\n-  // canvasWrap$.appendChild(app.view)\n   //   const renderer = new PIXI.Renderer({\n   //     width: canvasWrapWidth,\n   //     height: canvasWrapHeight,\n   //     resolution: window.devicePixelRatio,\n   //     autoDensity: true,\n   //     antialias: true,\n   //     view: canvas$,\n   //   })\n-  const stage = new PIXI.Container()\n+  //   const stage = new PIXI.Container()\n   const svg = 'https://uploads-ssl.webflow.com/64b5d89ecbb311f07e71739b/64c4afa6434d9807c6f188a7_map-woDots-pos2.svg'\n   const tex = PIXI.Texture.from(svg, { resourceOptions: { scale: 2 } })\n   const sprite = new PIXI.Sprite(tex)\n   const cont = new PIXI.Container()\n   cont.pivot.set(1, 0)\n-  stage.addChild(cont)\n+  app.stage.addChild(cont)\n   sprite.scale.set(0.1)\n   sprite.anchor.set(1, 0)\n   sprite.position.set(canvasWrapWidth, 0)\n   cont.addChild(sprite)\n \n   // const ticker = new PIXI.Ticker()\n   // ticker.stop()\n+  app.ticker.stop()\n   gsap.ticker.add(() => {\n     // ticker.update()\n     sprite.position.set(canvasWrapWidth, 0)\n-    renderer.render(stage)\n+    app.ticker.update()\n+    // renderer.render(stage)\n   })\n   let canvasSc = null\n   const canvasScInit = () => {\n     canvasSc = ScrollTrigger.create({\n"
                }
            ],
            "date": 1690685693529,
            "name": "Commit-0",
            "content": "import './style.styl'\nimport gsap from 'gsap'\nimport CSSRulePlugin from 'gsap/CSSRulePlugin'\nimport ScrollTrigger from 'gsap/ScrollTrigger'\nimport Flip from 'gsap/Flip'\nimport Lenis from '@studio-freight/lenis'\nimport Swiper from 'swiper'\nimport { Navigation, Autoplay, EffectFade } from 'swiper/modules'\nimport 'swiper/css'\nimport 'swiper/css/effect-fade'\n// import { Application, Assets, Sprite } from 'pixi.js'\nimport * as PIXI from 'pixi.js'\n\ngsap.registerPlugin(CSSRulePlugin, ScrollTrigger, Flip)\nconst mm = gsap.matchMedia()\n\nconst sel = (e) => document.querySelector(e)\nconst selAll = (e) => document.querySelectorAll(e)\n\nconst lenis = new Lenis()\nfunction raf(time) {\n  lenis.raf(time)\n  requestAnimationFrame(raf)\n}\nrequestAnimationFrame(raf)\n\nswitch (sel('.page-wrapper').getAttribute('data-page')) {\n  case 'canvas':\n    canvas()\n    break\n  case 'blog':\n    blog()\n    break\n  case 'blog-post':\n    blogPost()\n    break\n  default:\n    home()\n}\nfunction canvas() {\n  console.log('canvas')\n\n  const mapCard$a = selAll('.map-sec__card')\n  const mapCardWrapIn$a = selAll('.map-sec__card-wrapin')\n  const mapCardWrap$a = selAll('.map-sec__card-wrap')\n\n  const mapSec_ = 'map-sec'\n  const mapDotActive_ = 'canvas__map__dot--active'\n  const mapDotLine_ = 'canvas__map__dot__line'\n\n  const map$ = sel('.canvas__map')\n  const mapSec$ = sel(mapSec_)\n  const mapWrap$ = sel('.canvas__map-wrap')\n  const mapWrapIn$ = sel('.canvas__map-wrapin')\n  const mapFg$ = sel('.canvas__map__fg')\n  const mapFgWrap$ = sel('.canvas__map__fg-wrap')\n  const mapDot$a = selAll('.canvas__map__dot')\n  const mapBg$ = sel('.canvas__map__bg-img')\n  const mapBgWrap$ = sel('.canvas__map__bg-wrap')\n\n  // const vpWidth = document.documentElement.clientWidth\n  // const vpHight = document.documentElement.clientHeight\n  const canvasWrap$ = sel('.canvas-wrap')\n  let canvasWrapWidth = canvasWrap$.clientWidth\n  let canvasWrapHeight = canvasWrap$.clientHeight\n  canvasWrap$.appendChild(document.createElement('canvas'))\n  const canvas$ = sel('canvas')\n  // const app = new PIXI.Application({\n  //   width: canvasWrapWidth,\n  //   height: canvasWrapHeight,\n  //   resolution: window.devicePixelRatio,\n  //   autoDensity: true,\n  //   antialias: true,\n  // })\n  // const app = new PIXI.Application({ width: canvasWrapWidth, height: canvasWrapHeight, resolution: 1, antialias: true })\n  // const app = new PIXI.Application({ width: vpWidth, height: vpHight, resolution: 1, antialias: true })\n  // canvasWrap$.appendChild(app.view)\n  const renderer = new PIXI.Renderer({\n    width: canvasWrapWidth,\n    height: canvasWrapHeight,\n    resolution: window.devicePixelRatio,\n    autoDensity: true,\n    antialias: true,\n    view: canvas$,\n  })\n  const stage = new PIXI.Container()\n  const svg = 'https://uploads-ssl.webflow.com/64b5d89ecbb311f07e71739b/64c4afa6434d9807c6f188a7_map-woDots-pos2.svg'\n  const tex = PIXI.Texture.from(svg, { resourceOptions: { scale: 2 } })\n  const sprite = new PIXI.Sprite(tex)\n  const cont = new PIXI.Container()\n  cont.pivot.set(1, 0)\n  stage.addChild(cont)\n  sprite.scale.set(0.1)\n  sprite.anchor.set(1, 0)\n  sprite.position.set(canvasWrapWidth, 0)\n  cont.addChild(sprite)\n\n  // const ticker = new PIXI.Ticker()\n  // ticker.stop()\n  gsap.ticker.add(() => {\n    // ticker.update()\n    sprite.position.set(canvasWrapWidth, 0)\n    renderer.render(stage)\n  })\n  let canvasSc = null\n  const canvasScInit = () => {\n    canvasSc = ScrollTrigger.create({\n      animation: gsap\n        .timeline({ defaults: { ease: 'none' } })\n        .to(sprite.scale, { x: 2, y: 2 }, 0)\n        .to(sprite, { y: -2000 }, 0)\n        .to(cont, { x: -2000 }),\n      pin: true,\n      trigger: '.canvas-wrap',\n      start: 'top top',\n      end: 'bottom+=1000 top',\n      scrub: 1,\n    })\n  }\n  canvasScInit()\n  window.addEventListener(\n    'resize',\n    debounce(() => {\n      canvasWrapWidth = canvasWrap$.clientWidth\n      canvasWrapHeight = canvasWrap$.clientHeight\n      // canvasWrapWidth = renderer.view.parentNode.clientWidth\n      // canvasWrapHeight = renderer.view.parentNode.clientHeight\n      // app.renderer.resize(canvasWrapWidth, canvasWrapHeight)\n      // console.log('qwe')\n\n      // app.ticker.update()\n      // app.render()\n      renderer.resize(canvasWrapWidth, canvasWrapHeight)\n      if (canvasSc != null)\n        canvasSc.kill(() => {\n          canvasScInit()\n        })\n      // canvas$.style.width = canvasWrapWidth\n      // renderer.render(stage)\n    })\n  )\n  const mapDotRemoveActiveClass = () => {\n    const activeDots = [...mapDot$a].filter((el) => el.classList.contains(mapDotActive_))\n    activeDots.forEach((el) => el.classList.remove(mapDotActive_))\n  }\n  const cardSpeed = 0.5\n  let mapCardInAni\n  let mapCardOutAni\n  let mapScrollInitTl\n  mapDotRemoveActiveClass()\n\n  mapScrollInitTl = gsap\n    .timeline({ defaults: { ease: 'none', duration: 5 } })\n    .to(mapFg$, { y: '-20vh' }, 0)\n    .to(mapBg$, { y: '-10vh' }, 0)\n    .to(mapFg$, { scale: 1.2 }, 0)\n    .to(mapBg$, { scale: 1.2 * 0.84 }, 0)\n    .to(\n      {},\n      {\n        onComplete: mapCardInAni,\n        onCompleteParams: [0],\n        onReverseComplete: mapCardOutAni,\n        onReverseCompleteParams: [0, 'scrollingUp'],\n        duration: 0.001,\n      },\n      3.5\n    )\n    .addLabel('mapIntroDone', '>')\n  mapCardInAni = (i) => {\n    if (elementInViewport('.' + mapSec_)) {\n      // prevent overlapping tweens on fast scroll (end/home on keyboard)\n      gsap.timeline().to(mapCardWrap$a[i], { opacity: 1, top: '50%', duration: cardSpeed })\n      mapDot$a[i].classList.add(mapDotActive_)\n    }\n  }\n  mapCardOutAni = (i, scrollDirection = 'scrollingDown') => {\n    const direction = scrollDirection === 'scrollingUp' ? '55%' : '45%'\n    gsap.timeline().to(mapCardWrap$a[i], { opacity: 0, top: direction, duration: cardSpeed })\n    mapDotRemoveActiveClass()\n  }\n  const mapScrollTl = gsap\n    .timeline({ defaults: { ease: 'none', duration: 5 } })\n    .addLabel('card-a')\n    .to(mapFgWrap$, { y: '-60vh' }, 0)\n    .to(mapBgWrap$, { y: -60 * 0.8 + 'vh' }, 0)\n    .to(\n      {},\n      {\n        onComplete: mapCardOutAni,\n        onCompleteParams: [0],\n        onReverseComplete: mapCardInAni,\n        onReverseCompleteParams: [0],\n        duration: 0.001,\n      },\n      2.5 // DO NOT OVERLAP EVENT TWEENS!!!\n    )\n    .addLabel('card-b', 5)\n    .to(\n      {},\n      {\n        onComplete: mapCardInAni,\n        onCompleteParams: [1],\n        onReverseComplete: mapCardOutAni,\n        onReverseCompleteParams: [1, 'scrollingUp'],\n        duration: 0.001,\n      },\n      3.5\n    )\n    .set([mapFgWrap$, mapBgWrap$], { transformOrigin: '100% 60%' })\n    .to(mapFgWrap$, { scale: 1.9 }, 5)\n    .to(mapBgWrap$, { scale: 1.9 * 0.8 }, 5)\n    .to(\n      {},\n      {\n        onComplete: mapCardOutAni,\n        onCompleteParams: [1],\n        onReverseComplete: mapCardInAni,\n        onReverseCompleteParams: [1],\n        duration: 0.001,\n      },\n      7.5\n    )\n    .addLabel('card-c', 10)\n    .to(\n      {},\n      {\n        onComplete: mapCardInAni,\n        onCompleteParams: [2],\n        onReverseComplete: mapCardOutAni,\n        onReverseCompleteParams: [2, 'scrollingUp'],\n        duration: 0.001,\n      },\n      8.5\n    )\n    .to(mapFgWrap$, { y: '-85vh' }, 10)\n    .to(mapBgWrap$, { y: -85 * 0.8 + 'vh' }, 10)\n    .to(\n      {},\n      {\n        onComplete: mapCardOutAni,\n        onCompleteParams: [2],\n        onReverseComplete: mapCardInAni,\n        onReverseCompleteParams: [2],\n        duration: 0.001,\n      },\n      14\n    )\n    .addLabel('finish', 15)\n  const mapStAnimation = ScrollTrigger.create({\n    animation: mapScrollTl,\n    trigger: mapSec$,\n    start: 'top top',\n    end: 'bottom+=1000 top',\n    pin: mapWrap$,\n    scrub: 1,\n    snap: 'labelsDirectional',\n    duration: { min: 0.2, max: 1 },\n  })\n\n  mapCardWrap$a.forEach((el) => {\n    gsap.set(el, { opacity: 0, position: 'fixed', top: '55%', translateY: '-50%' })\n  })\n  const mapInitStAnimation = ScrollTrigger.create({\n    animation: mapScrollInitTl,\n    trigger: mapSec$,\n    start: 'top 80%',\n    end: 'top top',\n    scrub: 1,\n    snap: 1,\n  })\n  const mapDotsObserver = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.target.classList.contains(mapDotActive_)) {\n        window.addEventListener('scroll', () => {\n          if (mapStAnimation.isActive || mapInitStAnimation.isActive) {\n            const mapFgScale = gsap.getProperty(mapFg$, 'scale')\n            const mapFgWrapScale = gsap.getProperty(mapFgWrap$, 'scale')\n            const lineWidth = (mutation.target.getBoundingClientRect().left - mapCard$a[0].getBoundingClientRect().right - 30) / (mapFgScale * mapFgWrapScale)\n            mutation.target.querySelector('.' + mapDotLine_).style.width = lineWidth + 'px'\n          }\n        })\n      }\n    })\n  })\n  for (let mapDot of mapDot$a) {\n    // mapDotsObserver.observe(mapDot, { attributes: true, attributeFilter: ['class'] })\n  }\n}\nfunction blog() {\n  mm.add('(min-width: 992px)', () => {\n    {\n      const heroImg = sel('.blog-hero__img')\n      const heroImgWrap = sel('.blog-hero__img-wrap')\n      const heroInfo = sel('.blog-hero__info')\n      const blogCard$a = selAll('.blog-card')\n      const blogItems = sel('.blog__items')\n\n      gsap\n        .timeline({ defaults: { ease: 'power4.out', duration: 3 } })\n        .from('html', { '--blog-hero__img-outline-width': 'calc(100% - 300px)', duration: 1 }, 0)\n        .fromTo(heroImgWrap, { width: '100%' }, { width: 520 }, '-=1.4')\n        .from(heroInfo, { opacity: 0, y: 100 }, 0)\n\n      if (document.documentElement.clientHeight / 2 < blogCard$a[0].getBoundingClientRect().top) {\n        ScrollTrigger.create({\n          animation: gsap\n            .timeline()\n            .from([blogCard$a[0], blogCard$a[1], blogCard$a[2]], { opacity: 0, y: 100, duration: 1, ease: 'power2.out', stagger: 0.15 }, 0),\n          trigger: blogItems,\n          start: 'top center',\n        })\n      }\n    }\n  })\n}\nfunction blogPost() {\n  console.log('blog post')\n}\n\nfunction home() {\n  const videoHero$ = sel('.video-hero')\n  const introSec$ = sel('.intro-sec')\n  const aboutSec$ = sel('.about-sec')\n  const mapSec$ = sel('.map-sec')\n  const featuresSec$ = sel('.features-sec')\n  let mapSwiper\n\n  devMode(0)\n  function devMode(mode) {\n    if (mode === 0) {\n      return\n    } else if (mode === 1) {\n      let i = 0\n      document.querySelectorAll('[data-video-urls]').forEach((el) => {\n        el.querySelector('video').remove()\n        i++\n      })\n      console.log('devMode, removed videos:', i)\n    } else if (mode === 2) {\n      const devRemoveList = [videoHero$, introSec$, aboutSec$]\n      devRemoveList.forEach((el) => {\n        el.remove()\n      })\n      // sel('.page-wrapper').style.paddingTop = '80vh'\n      console.log('devMode: removing sections')\n    }\n  }\n\n  const introCard$ = sel('.intro-sec__card-wrap')\n\n  const mapCardsWrapIn_ = '.map-sec__cards-wrapin' // swiper\n  const mapCards_ = '.map-sec__cards' // swiper-wrapper\n  const mapCardWrap_ = '.map-sec__card-wrap' // swiper-slide\n  const mapCardsWrap$ = sel('.map-sec__cards-wrap') // wrapper over swiper\n  const mapCardsWrapIn$ = sel(mapCardsWrapIn_) // swiper\n  const mapCards$ = sel(mapCards_) // swiper-wrapper\n  const mapCardWrap$a = selAll(mapCardWrap_) // swiper-slide\n  const mapCard$a = selAll('.map-sec__card')\n  const mapCardWrapIn$a = selAll('.map-sec__card-wrapin')\n\n  const mapSec_ = 'map-sec'\n  const mapDot_ = 'map__dot'\n  const mapDotA_ = 'map__dot--red-dog'\n  const mapDotB_ = 'map__dot--fort-knox'\n  const mapDotC_ = 'map__dot--usibelli'\n  const mapDotActive_ = 'map__dot--active'\n  const mapDotLine_ = 'map__dot__line'\n\n  const map$ = sel('.map-sec__map')\n  const mapWrap$ = sel('.map-sec__map-wrap')\n  const mapFg$ = sel('.map__fg')\n  const mapFgWrap$ = sel('.map__fg-wrap')\n  const mapDots$a = selAll('.map__dot')\n  const mapBg$ = sel('.map__bg-img')\n  const mapBgWrap$ = sel('.map__bg-wrap')\n\n  const mapDotRemoveActiveClass = () => {\n    const activeDots = [...mapDots$a].filter((el) => el.classList.contains(mapDotActive_))\n    activeDots.forEach((el) => el.classList.remove(mapDotActive_))\n  }\n  const cardSpeed = 0.5\n  let mapCardInAni\n  let mapCardOutAni\n  let mapScrollInitTl\n\n  let mapScrollTl\n  const featuresItem$a = selAll('.features-sec__item')\n  const featuresImg_ = 'features-sec__img'\n  const featuresImgWrap_ = 'features-sec__img-wrap'\n  const featuresInfo_ = 'features-sec__info'\n  const aboutProgressBar$a = selAll('.progress-line__bar')\n\n  let introCardStAnimation, aboutStAnimation, mapStAnimation, mapInitStAnimation, featuresStAnimation, featuresScrollTl\n  let introCardStTl\n  let aboutStTl\n  let mapDotsObserver\n\n  const aboutSwiper = new Swiper('.about-sec__slider', {\n    // disabled: true,\n    slidesPerView: 1,\n    slidesPerGroup: 1,\n    spaceBetween: 20,\n    modules: [Navigation, Autoplay, EffectFade],\n    speed: 1000,\n    // rewind: true,\n    fadeEffect: {\n      crossFade: true,\n    },\n    effect: 'fade',\n    autoplay: {\n      delay: 5000,\n      disableOnInteraction: false,\n      stopOnLastSlide: true,\n    },\n    on: {\n      autoplayTimeLeft(s, time, progress) {\n        if (s.activeIndex < 2) {\n          const progIndex = s.activeIndex > 1 ? 1 : s.activeIndex\n          aboutProgressBar$a[progIndex].style.setProperty('--about-progress', (1 - progress) * 100 + '%')\n        }\n        // progressContent.textContent = `${Math.ceil(time / 1000)}s`;\n      },\n      realIndexChange: (s) => {\n        selAll('.progress__title.is--active').forEach((el) => {\n          el.classList.remove('is--active')\n        })\n        selAll('.progress__title')[s.realIndex].classList.add('is--active')\n        const progress = selAll('.progress-line')\n        if (s.realIndex === 1) {\n          progress[0].classList.add('hide')\n          progress[1].classList.remove('hide')\n        } else if (s.realIndex === 0) {\n          progress[0].classList.remove('hide')\n          progress[1].classList.add('hide')\n        }\n      },\n    },\n    navigation: {\n      nextEl: '.arrow-right',\n      prevEl: '.arrow-left',\n    },\n  })\n\n  mm.add('(min-width: 992px)', () => {\n    console.log('adding sc')\n    selAll('.progress__title').forEach((el, i) => {\n      el.addEventListener('click', () => {\n        aboutSwiper.slideTo(i)\n      })\n    })\n\n    if (mapSwiper) mapSwiper.destroy(true, true)\n    mapCardsWrapIn$.classList.remove('swiper')\n    mapCards$.classList.remove('swiper-wrapper')\n    mapCardWrap$a.forEach((el) => {\n      el.classList.remove('swiper-slide')\n    })\n    mapDotRemoveActiveClass()\n\n    mapCardInAni = (i) => {\n      if (elementInViewport('.' + mapSec_)) {\n        // prevent overlapping tweens on fast scroll (end/home on keyboard)\n        gsap.timeline().to(mapCardWrap$a[i], { opacity: 1, top: '50%', duration: cardSpeed })\n        mapDots$a[i].classList.add(mapDotActive_)\n      }\n    }\n    mapCardOutAni = (i, scrollDirection = 'scrollingDown') => {\n      const direction = scrollDirection === 'scrollingUp' ? '55%' : '45%'\n      gsap.timeline().to(mapCardWrap$a[i], { opacity: 0, top: direction, duration: cardSpeed })\n      mapDotRemoveActiveClass()\n    }\n\n    mapScrollInitTl = gsap\n      .timeline({ defaults: { ease: 'none', duration: 5 } })\n      .to(mapFg$, { y: '-20vh' }, 0)\n      .to(mapBg$, { y: '-10vh' }, 0)\n      .to(mapFg$, { scale: 1.2 }, 0)\n      .to(mapBg$, { scale: 1.2 * 0.84 }, 0)\n      .to(\n        {},\n        {\n          onComplete: mapCardInAni,\n          onCompleteParams: [0],\n          onReverseComplete: mapCardOutAni,\n          onReverseCompleteParams: [0, 'scrollingUp'],\n          duration: 0.001,\n        },\n        3.5\n      )\n      .addLabel('mapIntroDone', '>')\n    introCardStTl = gsap.timeline().to(introCard$, { transform: 'translate(0%, -80%)' })\n    aboutStTl = gsap\n      .timeline({ defaults: { duration: 3 } })\n      // .set('.card', { position: 'fixed' })\n      .set('.about-sec__item-wrap', { clipPath: 'inset(80px round 40px)' })\n      .to('.about-sec__item-wrap', { clipPath: 'inset(0px round 0px)' }, '<')\n      .to('.about-sec__slide__bg', { scale: 1.06 }, '<')\n      // .from('.card', { y: 50, opacity: 0, duration: 1.2 }, 0)\n      .from('.about-sec__progress', { opacity: 0, duration: 2 }, 1)\n    // .to('.about-sec__item-wrap', { borderRadius: '0', top: '0', bottom: '0', left: '0', right: '0' }, '<')\n    // .set('.card', { position: 'absolute' })\n    mapScrollTl = gsap\n      .timeline({ defaults: { ease: 'none', duration: 5 } })\n      .addLabel('card-a')\n      .to(mapFgWrap$, { y: '-60vh' }, 0)\n      .to(mapBgWrap$, { y: -60 * 0.8 + 'vh' }, 0)\n      .to(\n        {},\n        {\n          onComplete: mapCardOutAni,\n          onCompleteParams: [0],\n          onReverseComplete: mapCardInAni,\n          onReverseCompleteParams: [0],\n          duration: 0.001,\n        },\n        2.5 // DO NOT OVERLAP EVENT TWEENS!!!\n      )\n      .addLabel('card-b', 5)\n      .to(\n        {},\n        {\n          onComplete: mapCardInAni,\n          onCompleteParams: [1],\n          onReverseComplete: mapCardOutAni,\n          onReverseCompleteParams: [1, 'scrollingUp'],\n          duration: 0.001,\n        },\n        3.5\n      )\n      .set([mapFgWrap$, mapBgWrap$], { transformOrigin: '100% 60%' })\n      .to(mapFgWrap$, { scale: 1.9 }, 5)\n      .to(mapBgWrap$, { scale: 1.9 * 0.8 }, 5)\n      .to(\n        {},\n        {\n          onComplete: mapCardOutAni,\n          onCompleteParams: [1],\n          onReverseComplete: mapCardInAni,\n          onReverseCompleteParams: [1],\n          duration: 0.001,\n        },\n        7.5\n      )\n      .addLabel('card-c', 10)\n      .to(\n        {},\n        {\n          onComplete: mapCardInAni,\n          onCompleteParams: [2],\n          onReverseComplete: mapCardOutAni,\n          onReverseCompleteParams: [2, 'scrollingUp'],\n          duration: 0.001,\n        },\n        8.5\n      )\n      .to(mapFgWrap$, { y: '-85vh' }, 10)\n      .to(mapBgWrap$, { y: -85 * 0.8 + 'vh' }, 10)\n      .to(\n        {},\n        {\n          onComplete: mapCardOutAni,\n          onCompleteParams: [2],\n          onReverseComplete: mapCardInAni,\n          onReverseCompleteParams: [2],\n          duration: 0.001,\n        },\n        14\n      )\n      .addLabel('finish', 15)\n\n    introCardStAnimation = ScrollTrigger.create({\n      animation: introCardStTl,\n      trigger: '.intro-sec',\n      start: 'top bottom',\n      end: 'bottom top',\n      scrub: 1,\n    })\n    aboutStAnimation = ScrollTrigger.create({\n      animation: aboutStTl,\n      trigger: aboutSec$,\n      start: 'top top',\n      end: 'bottom center',\n      pin: aboutSec$,\n      scrub: 1,\n    })\n    mapStAnimation = ScrollTrigger.create({\n      animation: mapScrollTl,\n      trigger: mapSec$,\n      start: 'top top',\n      end: 'bottom+=1000 top',\n      pin: '.map-sec__map-wrap',\n      scrub: 1,\n      snap: 'labelsDirectional',\n      duration: { min: 0.2, max: 1 },\n    })\n\n    mapCardWrap$a.forEach((el) => {\n      gsap.set(el, { opacity: 0, position: 'fixed', top: '55%', translateY: '-50%' })\n    })\n    mapInitStAnimation = ScrollTrigger.create({\n      animation: mapScrollInitTl,\n      trigger: mapSec$,\n      start: 'top 80%',\n      end: 'top top',\n      scrub: 1,\n      snap: 1,\n    })\n    mapDotsObserver = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (mutation.target.classList.contains(mapDotActive_)) {\n          window.addEventListener('scroll', () => {\n            if (mapStAnimation.isActive || mapInitStAnimation.isActive) {\n              const mapFgScale = gsap.getProperty(mapFg$, 'scale')\n              const mapFgWrapScale = gsap.getProperty(mapFgWrap$, 'scale')\n              const lineWidth = (mutation.target.getBoundingClientRect().left - mapCard$a[0].getBoundingClientRect().right - 30) / (mapFgScale * mapFgWrapScale)\n              mutation.target.querySelector('.' + mapDotLine_).style.width = lineWidth + 'px'\n            }\n          })\n        }\n      })\n    })\n    for (let mapDot of mapDots$a) {\n      mapDotsObserver.observe(mapDot, { attributes: true, attributeFilter: ['class'] })\n    }\n    featuresItem$a.forEach((item) => {\n      const img = item.querySelector('.' + featuresImg_)\n      const imgWrap = item.querySelector('.' + featuresImgWrap_)\n      const info = item.querySelector('.' + featuresInfo_)\n      featuresScrollTl = gsap\n        .timeline({ defaults: { ease: 'power2.out', duration: 2 } })\n        .to(imgWrap, { marginLeft: 80, marginRight: 80 }, '0')\n        .from(imgWrap, { width: '100%' }, '0')\n        .from(info, { opacity: 0, y: 100 }, '0')\n      featuresStAnimation = ScrollTrigger.create({\n        animation: featuresScrollTl,\n        trigger: item,\n        start: 'top 80%',\n        duration: { min: 0.2, max: 1 },\n      })\n    })\n  })\n  mm.add('(max-width: 991px)', () => {\n    mapCardsWrapIn$.classList.add('swiper')\n    mapCards$.classList.add('swiper-wrapper')\n    mapCardWrap$a.forEach((el) => {\n      el.classList.add('swiper-slide')\n    })\n    mapSwiper = new Swiper('.map-sec__cards-wrapin', {\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      spaceBetween: 20,\n      modules: [Autoplay],\n      speed: 1000,\n      autoplay: {\n        delay: 5000,\n        disableOnInteraction: false,\n      },\n    })\n    mapSwiper.on('slideChange', () => {\n      mapDotRemoveActiveClass()\n      mapDots$a[mapSwiper.activeIndex].classList.add(mapDotActive_)\n    })\n    mapSwiper.slideNext()\n    mapDots$a.forEach((el, i) => {\n      el.style.cursor = 'pointer'\n      el.addEventListener('click', () => {\n        if (!el.classList.contains(mapDotActive_)) {\n          console.log('qwe')\n          mapDotRemoveActiveClass()\n          el.classList.add(mapDotActive_)\n          mapSwiper.slideTo(i)\n        }\n      })\n    })\n  })\n}\n\nfunction elementInViewport(el) {\n  const element = el instanceof Element ? el : document.querySelector(el)\n  const bounding = element.getBoundingClientRect()\n  const elementHeight = element.offsetHeight\n  const elementWidth = element.offsetWidth\n  if (\n    bounding.top >= -elementHeight &&\n    bounding.left >= -elementWidth &&\n    bounding.right <= (window.innerWidth || document.documentElement.clientWidth) + elementWidth &&\n    bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) + elementHeight\n  ) {\n    return true\n  } else {\n    return false\n  }\n}\n// Debounce\nfunction debounce(func, time = 100) {\n  let timer\n  return function (event) {\n    if (timer) clearTimeout(timer)\n    timer = setTimeout(func, time, event)\n  }\n}\n"
        }
    ]
}