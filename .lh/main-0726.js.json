{
    "sourceFile": "main-0726.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1690339151507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1690339151507,
            "name": "Commit-0",
            "content": "import './style.styl'\nimport gsap from 'gsap'\nimport CSSRulePlugin from 'gsap/CSSRulePlugin'\nimport ScrollTrigger from 'gsap/ScrollTrigger'\nimport Flip from 'gsap/Flip'\nimport Lenis from '@studio-freight/lenis'\n\nconst devMode = 1\ngsap.registerPlugin(CSSRulePlugin, ScrollTrigger, Flip)\n\nconst sel = (e) => document.querySelector(e)\nconst selAll = (e) => document.querySelectorAll(e)\n\nconst videoHero$ = sel('.video-hero')\nconst introSec$ = sel('.intro-sec')\nconst aboutSec$ = sel('.about-sec')\nconst mapSec$ = sel('.map-sec')\nconst featuresSec$ = sel('.features-sec')\n\nif (devMode) {\n  const devRemoveList = [videoHero$, introSec$]\n  document.querySelectorAll('[data-video-urls]').forEach((el) => {\n    el.querySelector('video').remove()\n  })\n  devRemoveList.forEach((el) => {\n    // el.remove()\n  })\n  // sel('.page-wrapper').style.paddingTop = '80vh'\n  console.log('dev mode')\n}\n\nconst lenis = new Lenis()\n\nfunction raf(time) {\n  lenis.raf(time)\n  requestAnimationFrame(raf)\n}\n\nrequestAnimationFrame(raf)\n\nconst introCard$ = sel('.intro-sec__card-wrap')\n\nScrollTrigger.create({\n  // markers: true,\n  animation: gsap.timeline().to(introCard$, { transform: 'translate(0%, -80%)' }),\n  trigger: '.intro-sec',\n  start: 'top bottom',\n  end: 'bottom top',\n  scrub: 1,\n})\n\nScrollTrigger.create({\n  // animation: gsap.timeline().to('.about-sec__item', { borderRadius: '0' }, '<').to(aboutSec$, { padding: '0' }, '<'),\n  animation: gsap.timeline().to('.about-sec__item-wrap', { borderRadius: '0', top: '0', bottom: '0', left: '0', right: '0' }, '<'),\n  trigger: aboutSec$,\n  start: 'top top',\n  end: 'bottom center',\n  pin: aboutSec$,\n  scrub: 1,\n  // anticipatePin: 1,\n  // pinType: 'fixed',\n})\n\nconst mapCards$ = selAll('.map-sec__card')\nconst mapCardsWrap$ = selAll('.map-sec__card-wrap')\nconst mapCardsWrapIn$ = selAll('.map-sec__card-wrapin')\n\nmapCardsWrap$.forEach((el) => {\n  gsap.set(el, { opacity: 0, position: 'fixed', top: '55%', translateY: '-50%' })\n})\n\n// ScrollTrigger.create({\n//   // animation: gsap.timeline().to(mapCards[0], { opacity: 0.5 }),\n//   trigger: mapCards$[1],\n//   start: 'center center',\n//   end: 'top top',\n//   // pin: mapCards[1],\n//   scrub: 1,\n//   // snap: 1,\n// })\n\nconst mapSec_ = 'map-sec'\nconst mapDot_ = 'map__dot'\nconst mapDotA_ = 'map__dot--red-dog'\nconst mapDotB_ = 'map__dot--fort-knox'\nconst mapDotC_ = 'map__dot--usibelli'\nconst mapDotActive_ = 'map__dot--active'\nconst mapDotLine_ = 'map__dot__line'\n\nconst map$ = sel('.map-sec__map')\nconst mapWrap$ = sel('.map-sec__map-wrap')\nconst mapFg$ = sel('.map__fg')\nconst mapFgWrap$ = sel('.map__fg-wrap')\nconst mapDots$ = selAll('.map__dot')\nconst mapBg$ = sel('.map__bg-img')\nconst mapBgWrap$ = sel('.map__bg-wrap')\n\nconst mapDotRemoveActiveClass = () => {\n  const activeDots = [...mapDots$].filter((el) => el.classList.contains(mapDotActive_))\n  activeDots.forEach((el) => el.classList.remove(mapDotActive_))\n}\nconst cardSpeed = 0.5\nconst mapCardInAni = (i) => {\n  if (elementInViewport('.' + mapSec_)) {\n    // prevent overlapping tweens on fast scroll (end/home on keyboard)\n    gsap.timeline().to(mapCardsWrap$[i], { opacity: 1, top: '50%', duration: cardSpeed })\n    mapDots$[i].classList.add(mapDotActive_)\n  }\n}\nconst mapCardOutAni = (i, scrollDirection = 'scrollingDown') => {\n  const direction = scrollDirection === 'scrollingUp' ? '55%' : '45%'\n  // prevent overlapping tweens on fast scroll (end/home on keyboard)\n  gsap.timeline().to(mapCardsWrap$[i], { opacity: 0, top: direction, duration: cardSpeed })\n  // gsap.set(mapCardsWrap$[i], { opacity: 0, top: direction })\n  mapDotRemoveActiveClass()\n}\nmapDotRemoveActiveClass()\nconst mapScrollInitTl = gsap\n  .timeline({ defaults: { ease: 'none', duration: 5 } })\n  .to(mapFg$, { y: '-20vh' }, 0)\n  .to(mapBg$, { y: '-10vh' }, 0)\n  .to(mapFg$, { scale: 1.2 }, 0)\n  .to(mapBg$, { scale: 1.2 * 0.84 }, 0)\n  .to(\n    {},\n    {\n      onComplete: mapCardInAni,\n      onCompleteParams: [0],\n      onReverseComplete: mapCardOutAni,\n      onReverseCompleteParams: [0, 'scrollingUp'],\n      duration: 0.001,\n    },\n    3.5\n  )\n  .addLabel('mapIntroDone', '>')\n\nconst mapInitStAnimation = ScrollTrigger.create({\n  animation: mapScrollInitTl,\n  trigger: mapSec$,\n  start: 'top 80%',\n  end: 'top top',\n  scrub: 1,\n  snap: 1,\n})\nconst mapScrollTl = gsap\n  .timeline({ defaults: { ease: 'none', duration: 5 } })\n  .addLabel('card-a')\n  .to(mapFgWrap$, { y: '-60vh' }, 0)\n  .to(mapBgWrap$, { y: -60 * 0.8 + 'vh' }, 0)\n  .to(\n    {},\n    {\n      onComplete: mapCardOutAni,\n      onCompleteParams: [0],\n      onReverseComplete: mapCardInAni,\n      onReverseCompleteParams: [0],\n      duration: 0.001,\n    },\n    2.5 // DO NOT OVERLAP EVENT TWEENS!!!\n  )\n  // .to(mapCardsWrapIn[0], { opacity: 0, y: '-5vh', duration: 1 }, 1)\n  .addLabel('card-b', 5)\n  .to(\n    {},\n    {\n      onComplete: mapCardInAni,\n      onCompleteParams: [1],\n      onReverseComplete: mapCardOutAni,\n      onReverseCompleteParams: [1, 'scrollingUp'],\n      duration: 0.001,\n    },\n    3.5\n  )\n  .set([mapFgWrap$, mapBgWrap$], { transformOrigin: '100% 60%' })\n  .to(mapFgWrap$, { scale: 1.9 }, 5)\n  .to(mapBgWrap$, { scale: 1.9 * 0.8 }, 5)\n  .to(\n    {},\n    {\n      onComplete: mapCardOutAni,\n      onCompleteParams: [1],\n      onReverseComplete: mapCardInAni,\n      onReverseCompleteParams: [1],\n      duration: 0.001,\n    },\n    7.5\n  )\n  .addLabel('card-c', 10)\n  .to(\n    {},\n    {\n      onComplete: mapCardInAni,\n      onCompleteParams: [2],\n      onReverseComplete: mapCardOutAni,\n      onReverseCompleteParams: [2, 'scrollingUp'],\n      duration: 0.001,\n    },\n    8.5\n  )\n  .to(mapFgWrap$, { y: '-85vh' }, 10)\n  .to(mapBgWrap$, { y: -85 * 0.8 + 'vh' }, 10)\n  .to(\n    {},\n    {\n      onComplete: mapCardOutAni,\n      onCompleteParams: [2],\n      onReverseComplete: mapCardInAni,\n      onReverseCompleteParams: [2],\n      duration: 0.001,\n    },\n    14\n  )\n  .addLabel('finish', 15)\n\nconst mapStAnimation = ScrollTrigger.create({\n  animation: mapScrollTl,\n  trigger: mapSec$,\n  // startTrigger: '.map-sec',\n  // endTrigger: mapCards[2],\n  start: 'top top',\n  end: 'bottom+=1000 top',\n  pin: '.map-sec__map-wrap',\n  scrub: 1,\n  snap: 'labelsDirectional',\n  duration: { min: 0.2, max: 1 },\n  // delay: 0.0,\n  // anticipatePin: true,\n  // pinSpacing: true,\n  // pinType: 'fixed',\n})\n\nconst observer = new MutationObserver((mutations) => {\n  mutations.forEach((mutation) => {\n    // if (mutationRecord.target.className === mapDotActive_) {\n    if (mutation.target.classList.contains(mapDotActive_)) {\n      window.addEventListener('scroll', () => {\n        if (mapStAnimation.isActive || mapInitStAnimation.isActive) {\n          const mapFgScale = gsap.getProperty(mapFg$, 'scale')\n          const mapFgWrapScale = gsap.getProperty(mapFgWrap$, 'scale')\n          const lineWidth = (mutation.target.getBoundingClientRect().left - mapCards$[0].getBoundingClientRect().right - 30) / (mapFgScale * mapFgWrapScale)\n          // console.log(mapFgScale, window.getComputedStyle(mapFg$).getPropertyValue(display), lineWidth)\n          // console.log(mapFgScale, mapFgWrapScale, lineWidth)\n          mutation.target.querySelector('.' + mapDotLine_).style.width = lineWidth + 'px'\n          // const line = mutation.target.querySelector('.' + mapDotLine_)\n          // gsap.timeline().fromTo(line, { width: 0 }, { width: lineWidth, ease: 'none' }, 0)\n        }\n      })\n    }\n  })\n})\n\nfor (let mapDot of mapDots$) {\n  observer.observe(mapDot, { attributes: true, attributeFilter: ['class'] })\n}\n\nconst featuresItem$ = selAll('.features-sec__item')\nconst featuresImg_ = 'features-sec__img'\nconst featuresImgWrap_ = 'features-sec__img-wrap'\nconst featuresInfo_ = 'features-sec__info'\n\nfeaturesItem$.forEach((item) => {\n  const img = item.querySelector('.' + featuresImg_)\n  const imgWrap = item.querySelector('.' + featuresImgWrap_)\n  const info = item.querySelector('.' + featuresInfo_)\n  const featuresScrollTl = gsap\n    .timeline({ defaults: { ease: 'power2.out', duration: 2 } })\n    .to(imgWrap, { marginLeft: 80, marginRight: 80 }, '0')\n    .from(imgWrap, { width: '100%' }, '0')\n    // .to(imgWrap, { paddingLeft: '80px', paddingRight: '80px' }, '0')\n    .from(info, { opacity: 0, y: 100 }, '0')\n  ScrollTrigger.create({\n    animation: featuresScrollTl,\n    trigger: item,\n    start: 'top 80%',\n    // end: 'top 15%',\n    // scrub: 1,\n    // snap: 1,\n    duration: { min: 0.2, max: 1 },\n  })\n  // gsap.from(imgWrap, { width: '100%', duration: 1, scrollTrigger: { trigger: imgWrap, start: 'top 85%', end: 'top 15%', scrub: true } })\n})\n\nconst mqInit = () => {\n  console.log(mqMin('desk'))\n}\n\nconst screen = {\n  mob: 0,\n  mobLand: 479,\n  tab: 768,\n  desk: 992,\n  hd: 1440,\n  uhd: 1920,\n}\nlet screenMq = {}\nObject.entries(screen).forEach(([scr, mq], i) => {\n  if (i === 0) {\n    // mobile\n    screenMq[scr] = window.matchMedia(`(max-width: ${Object.values(screen)[i + 1] - 1}px)`)\n  } else if (i === Object.keys(screen).length - 1) {\n    // uhd/4k\n    screenMq[scr] = window.matchMedia(`(min-width: ${mq}px)`)\n  } // the rest\n  else screenMq[scr] = window.matchMedia(`(min-width: ${mq}px) and (max-width: ${Object.values(screen)[i + 1]}px)`)\n})\n\n// media query change events\nfor (let [scr, mq] of Object.entries(screenMq)) {\n  mq.addEventListener('change', mqHandler)\n  // console.log('mq added:' + scr)\n}\n\n// media query handler function\nlet mqNow = null\nfunction mqHandler() {\n  for (let [scr, mq] of Object.entries(screenMq)) {\n    if (mq.matches) mqNow = scr\n  }\n  mqInit()\n  // console.log(mqNow)\n}\nmqHandler()\n\nfunction mqMax(device) {\n  const deviceIndex = Object.keys(screen).indexOf(device)\n  const mqNowIndex = Object.keys(screen).indexOf(mqNow)\n  if (mqNowIndex <= deviceIndex) return true\n  else return false\n}\nfunction mqMin(device) {\n  const deviceIndex = Object.keys(screen).indexOf(device)\n  const mqNowIndex = Object.keys(screen).indexOf(mqNow)\n  if (mqNowIndex >= deviceIndex) return true\n  else return false\n}\n// window.addEventListener('resize', () => {\n//   // if (mqMin('tab')) // console.log('qwe')\n//   mqInit()\n// })\n\nfunction elementInViewport(el) {\n  const element = el instanceof Element ? el : document.querySelector(el)\n  const bounding = element.getBoundingClientRect()\n  const elementHeight = element.offsetHeight\n  const elementWidth = element.offsetWidth\n  if (\n    bounding.top >= -elementHeight &&\n    bounding.left >= -elementWidth &&\n    bounding.right <= (window.innerWidth || document.documentElement.clientWidth) + elementWidth &&\n    bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) + elementHeight\n  ) {\n    return true\n  } else {\n    return false\n  }\n}\n"
        }
    ]
}