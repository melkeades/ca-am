{
    "sourceFile": "main-0726-21.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1690396239354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1690396239354,
            "name": "Commit-0",
            "content": "import './style.styl'\nimport gsap from 'gsap'\nimport CSSRulePlugin from 'gsap/CSSRulePlugin'\nimport ScrollTrigger from 'gsap/ScrollTrigger'\nimport Flip from 'gsap/Flip'\nimport Lenis from '@studio-freight/lenis'\n\ndevMode(1)\ngsap.registerPlugin(CSSRulePlugin, ScrollTrigger, Flip)\ngsap.config({ force3D: true })\nconst sel = (e) => document.querySelector(e)\nconst selAll = (e) => document.querySelectorAll(e)\n\nconst videoHero$ = sel('.video-hero')\nconst introSec$ = sel('.intro-sec')\nconst aboutSec$ = sel('.about-sec')\nconst mapSec$ = sel('.map-sec')\nconst featuresSec$ = sel('.features-sec')\n\nfunction devMode(mode) {\n  if (mode === 0) {\n    return\n  } else if (mode === 1) {\n    let i = 0\n    document.querySelectorAll('[data-video-urls]').forEach((el) => {\n      el.querySelector('video').remove()\n      i++\n    })\n    console.log('devMode, removed videos:', i)\n  } else if (mode === 2) {\n    const devRemoveList = [videoHero$, introSec$]\n    devRemoveList.forEach((el) => {\n      el.remove()\n    })\n    sel('.page-wrapper').style.paddingTop = '80vh'\n    console.log('devMode: removing sections')\n  }\n}\nconst lenis = new Lenis()\n\nfunction raf(time) {\n  lenis.raf(time)\n  requestAnimationFrame(raf)\n}\n\nrequestAnimationFrame(raf)\n\nconst introCard$ = sel('.intro-sec__card-wrap')\n\nconst mapCards$ = selAll('.map-sec__card')\nconst mapCardsWrap$ = selAll('.map-sec__card-wrap')\nconst mapCardsWrapIn$ = selAll('.map-sec__card-wrapin')\n\nconst mapSec_ = 'map-sec'\nconst mapDot_ = 'map__dot'\nconst mapDotA_ = 'map__dot--red-dog'\nconst mapDotB_ = 'map__dot--fort-knox'\nconst mapDotC_ = 'map__dot--usibelli'\nconst mapDotActive_ = 'map__dot--active'\nconst mapDotLine_ = 'map__dot__line'\n\nconst map$ = sel('.map-sec__map')\nconst mapWrap$ = sel('.map-sec__map-wrap')\nconst mapFg$ = sel('.map__fg')\nconst mapFgWrap$ = sel('.map__fg-wrap')\nconst mapDots$ = selAll('.map__dot')\nconst mapBg$ = sel('.map__bg-img')\nconst mapBgWrap$ = sel('.map__bg-wrap')\n\nconst mapDotRemoveActiveClass = () => {\n  const activeDots = [...mapDots$].filter((el) => el.classList.contains(mapDotActive_))\n  activeDots.forEach((el) => el.classList.remove(mapDotActive_))\n}\nconst cardSpeed = 0.5\nconst mapCardInAni = (i) => {\n  if (elementInViewport('.' + mapSec_)) {\n    // prevent overlapping tweens on fast scroll (end/home on keyboard)\n    gsap.timeline().to(mapCardsWrap$[i], { opacity: 1, top: '50%', duration: cardSpeed })\n    mapDots$[i].classList.add(mapDotActive_)\n  }\n}\nconst mapCardOutAni = (i, scrollDirection = 'scrollingDown') => {\n  const direction = scrollDirection === 'scrollingUp' ? '55%' : '45%'\n  gsap.timeline().to(mapCardsWrap$[i], { opacity: 0, top: direction, duration: cardSpeed })\n  mapDotRemoveActiveClass()\n}\nmapDotRemoveActiveClass()\nconst mapScrollInitTl = gsap\n  .timeline({ defaults: { ease: 'none', duration: 5 } })\n  .to(mapFg$, { y: '-20vh' }, 0)\n  .to(mapBg$, { y: '-10vh' }, 0)\n  .to(mapFg$, { scale: 1.2 }, 0)\n  .to(mapBg$, { scale: 1.2 * 0.84 }, 0)\n  .to(\n    {},\n    {\n      onComplete: mapCardInAni,\n      onCompleteParams: [0],\n      onReverseComplete: mapCardOutAni,\n      onReverseCompleteParams: [0, 'scrollingUp'],\n      duration: 0.001,\n    },\n    3.5\n  )\n  .addLabel('mapIntroDone', '>')\n\nconst mapScrollTl = gsap\n  .timeline({ defaults: { ease: 'none', duration: 5 } })\n  .addLabel('card-a')\n  .to(mapFgWrap$, { y: '-60vh' }, 0)\n  .to(mapBgWrap$, { y: -60 * 0.8 + 'vh' }, 0)\n  .to(\n    {},\n    {\n      onComplete: mapCardOutAni,\n      onCompleteParams: [0],\n      onReverseComplete: mapCardInAni,\n      onReverseCompleteParams: [0],\n      duration: 0.001,\n    },\n    2.5 // DO NOT OVERLAP EVENT TWEENS!!!\n  )\n  .addLabel('card-b', 5)\n  .to(\n    {},\n    {\n      onComplete: mapCardInAni,\n      onCompleteParams: [1],\n      onReverseComplete: mapCardOutAni,\n      onReverseCompleteParams: [1, 'scrollingUp'],\n      duration: 0.001,\n    },\n    3.5\n  )\n  .set([mapFgWrap$, mapBgWrap$], { transformOrigin: '100% 60%' })\n  .to(mapFgWrap$, { scale: 1.9 }, 5)\n  .to(mapBgWrap$, { scale: 1.9 * 0.8 }, 5)\n  .to(\n    {},\n    {\n      onComplete: mapCardOutAni,\n      onCompleteParams: [1],\n      onReverseComplete: mapCardInAni,\n      onReverseCompleteParams: [1],\n      duration: 0.001,\n    },\n    7.5\n  )\n  .addLabel('card-c', 10)\n  .to(\n    {},\n    {\n      onComplete: mapCardInAni,\n      onCompleteParams: [2],\n      onReverseComplete: mapCardOutAni,\n      onReverseCompleteParams: [2, 'scrollingUp'],\n      duration: 0.001,\n    },\n    8.5\n  )\n  .to(mapFgWrap$, { y: '-85vh' }, 10)\n  .to(mapBgWrap$, { y: -85 * 0.8 + 'vh' }, 10)\n  .to(\n    {},\n    {\n      onComplete: mapCardOutAni,\n      onCompleteParams: [2],\n      onReverseComplete: mapCardInAni,\n      onReverseCompleteParams: [2],\n      duration: 0.001,\n    },\n    14\n  )\n  .addLabel('finish', 15)\n\nconst featuresItem$ = selAll('.features-sec__item')\nconst featuresImg_ = 'features-sec__img'\nconst featuresImgWrap_ = 'features-sec__img-wrap'\nconst featuresInfo_ = 'features-sec__info'\n\nlet introCardStAnimation, aboutStAnimation, mapStAnimation, mapInitStAnimation, featuresStAnimation, featuresScrollTl\nconst introCardStTl = gsap.timeline().to(introCard$, { transform: 'translate(0%, -80%)' })\n// const introCardStTl = gsap.timeline({ defaults: { paused: true } }).to(introCard$, { transform: 'translate(0%, -80%)' })\nconst aboutStTl = gsap.timeline().to('.about-sec__item-wrap', { borderRadius: '0', top: '0', bottom: '0', left: '0', right: '0' }, '<')\nlet mapDotsObserver\n// introCardStAnimation = gsap.timeline({\n//   ScrollTrigger: {\n//     trigger: '.intro-sec',\n//     start: 'top bottom',\n//     end: 'bottom top',\n//     scrub: 1,\n//     markers: true,\n//   },\n// })\n// introCardStAnimation.to(introCard$, { transform: 'translate(0%, -80%)' })\nconst mqInit = () => {\n  if (mqMin('desk')) {\n    if (mqPrev === null || mqPrev === 'tab') {\n      console.log('adding sc')\n      introCardStAnimation = ScrollTrigger.create({\n        animation: introCardStTl,\n        trigger: '.intro-sec',\n        start: 'top bottom',\n        end: 'bottom top',\n        scrub: 1,\n      })\n      aboutStAnimation = ScrollTrigger.create({\n        animation: aboutStTl,\n        trigger: aboutSec$,\n        start: 'top top',\n        end: 'bottom center',\n        pin: aboutSec$,\n        scrub: 1,\n      })\n      mapStAnimation = ScrollTrigger.create({\n        animation: mapScrollTl,\n        trigger: mapSec$,\n        start: 'top top',\n        end: 'bottom+=1000 top',\n        pin: '.map-sec__map-wrap',\n        scrub: 1,\n        snap: 'labelsDirectional',\n        duration: { min: 0.2, max: 1 },\n      })\n\n      mapCardsWrap$.forEach((el) => {\n        gsap.set(el, { opacity: 0, position: 'fixed', top: '55%', translateY: '-50%' })\n      })\n      mapInitStAnimation = ScrollTrigger.create({\n        animation: mapScrollInitTl,\n        trigger: mapSec$,\n        start: 'top 80%',\n        end: 'top top',\n        scrub: 1,\n        snap: 1,\n      })\n      mapDotsObserver = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n          if (mutation.target.classList.contains(mapDotActive_)) {\n            window.addEventListener('scroll', () => {\n              if (mapStAnimation.isActive || mapInitStAnimation.isActive) {\n                const mapFgScale = gsap.getProperty(mapFg$, 'scale')\n                const mapFgWrapScale = gsap.getProperty(mapFgWrap$, 'scale')\n                const lineWidth =\n                  (mutation.target.getBoundingClientRect().left - mapCards$[0].getBoundingClientRect().right - 30) / (mapFgScale * mapFgWrapScale)\n                mutation.target.querySelector('.' + mapDotLine_).style.width = lineWidth + 'px'\n              }\n            })\n          }\n        })\n      })\n      for (let mapDot of mapDots$) {\n        mapDotsObserver.observe(mapDot, { attributes: true, attributeFilter: ['class'] })\n      }\n      featuresItem$.forEach((item) => {\n        const img = item.querySelector('.' + featuresImg_)\n        const imgWrap = item.querySelector('.' + featuresImgWrap_)\n        const info = item.querySelector('.' + featuresInfo_)\n        featuresScrollTl = gsap\n          .timeline({ defaults: { ease: 'power2.out', duration: 2 } })\n          .to(imgWrap, { marginLeft: 80, marginRight: 80 }, '0')\n          .from(imgWrap, { width: '100%' }, '0')\n          .from(info, { opacity: 0, y: 100 }, '0')\n        featuresStAnimation = ScrollTrigger.create({\n          animation: featuresScrollTl,\n          trigger: item,\n          start: 'top 80%',\n          duration: { min: 0.2, max: 1 },\n        })\n      })\n    }\n  } else {\n    console.log('removing sc')\n\n    // introCardStAnimation.kill()\n    ScrollTrigger.killAll(true, false)\n    introCardStTl.revert()\n    aboutStTl.revert()\n    if (introCardStAnimation) {\n      // introCardStTl.kill()\n    }\n    if (aboutStAnimation) {\n      aboutStAnimation.kill()\n      aboutStTl.kill()\n    }\n    if (mapStAnimation) {\n      mapStAnimation.kill()\n      mapScrollTl.kill()\n    }\n    if (mapInitStAnimation) {\n      mapInitStAnimation.kill()\n      mapScrollInitTl.kill()\n    }\n    if (featuresStAnimation) {\n      featuresStAnimation.kill()\n      featuresScrollTl.kill()\n    }\n    if (mapDotsObserver) mapDotsObserver.disconnect()\n    mapCardsWrap$.forEach((el) => {\n      gsap.set(el, { opacity: 1, position: 'relative', top: '0', translateY: '0' })\n    })\n  }\n}\nconst screen = {\n  mob: 0,\n  mobLand: 479,\n  tab: 768,\n  desk: 992,\n  hd: 1440,\n  uhd: 1920,\n}\nlet screenMq = {}\nObject.entries(screen).forEach(([scr, mq], i) => {\n  if (i === 0) {\n    // mobile\n    screenMq[scr] = window.matchMedia(`(max-width: ${Object.values(screen)[i + 1] - 1}px)`)\n  } else if (i === Object.keys(screen).length - 1) {\n    // uhd/4k\n    screenMq[scr] = window.matchMedia(`(min-width: ${mq}px)`)\n  } // the rest\n  else screenMq[scr] = window.matchMedia(`(min-width: ${mq}px) and (max-width: ${Object.values(screen)[i + 1]}px)`)\n})\n\n// media query change events\nfor (let [scr, mq] of Object.entries(screenMq)) {\n  mq.addEventListener('change', mqHandler)\n  // console.log('mq added:' + scr)\n}\n\n// media query handler function\nlet mqNow = null\nlet mqPrev\nfunction mqHandler() {\n  for (let [scr, mq] of Object.entries(screenMq)) {\n    if (mq.matches && mqNow !== scr) {\n      mqPrev = mqNow\n      mqNow = scr\n    }\n  }\n  mqInit()\n  // console.log(mqNow)\n}\nmqHandler()\n\nfunction mqMax(device) {\n  const deviceIndex = Object.keys(screen).indexOf(device)\n  const mqNowIndex = Object.keys(screen).indexOf(mqNow)\n  if (mqNowIndex <= deviceIndex) return true\n  else return false\n}\nfunction mqMin(device) {\n  const deviceIndex = Object.keys(screen).indexOf(device)\n  const mqNowIndex = Object.keys(screen).indexOf(mqNow)\n  if (mqNowIndex >= deviceIndex) return true\n  else return false\n}\n\nfunction elementInViewport(el) {\n  const element = el instanceof Element ? el : document.querySelector(el)\n  const bounding = element.getBoundingClientRect()\n  const elementHeight = element.offsetHeight\n  const elementWidth = element.offsetWidth\n  if (\n    bounding.top >= -elementHeight &&\n    bounding.left >= -elementWidth &&\n    bounding.right <= (window.innerWidth || document.documentElement.clientWidth) + elementWidth &&\n    bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) + elementHeight\n  ) {\n    return true\n  } else {\n    return false\n  }\n}\n"
        }
    ]
}